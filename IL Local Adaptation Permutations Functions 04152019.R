permute = function(data, SPLIT, RESPONSE, 
                          center=TRUE, seed=FALSE){#,
                          # scale=TRUE) {
  # Split data on SPLIT factor, then permute RESPONSE and calculate centered value
  
  
  if (seed) set.seed(seed)
  
  # Permute and calculate centered value
  dd = split(data, data[, SPLIT])
  
  dd = lapply(dd, function(x) {
    x[, RESPONSE] = sample(x[, RESPONSE])
    return(x)
  })
  # 
  # if (center | scale) {
  #   dd = lapply(dd, function(x) {
  #     x[, 'CENTERED'] = scale(x[, RESPONSE], center=center, scale=scale)
  #     return(x)
  #   })
  # }
  
  dd = as.data.frame(
    do.call(rbind, dd)
  )
  rownames(dd) = NULL
  
  return(dd)
}


scale_by_formula = function(data, formula) {
  means = aggregate(formula, data, function(x) mean(x, na.rm=TRUE))
  sds = aggregate(formula, data, function(x) sd(x, na.rm=TRUE))
  
  fact_cols = seq(1:(ncol(means)-1))
  factors = names(means)[fact_cols]
  response = names(means)[ncol(means)]
  
  mean_sd = merge(means, sds, by=factors)
  colnames(mean_sd)[-fact_cols] = c('MEAN', 'SD')
  
  data = merge(data, mean_sd, by=factors)
  
  data[, 'STANDARDIZED'] = (data[, response] - data[, 'MEAN']) / data[, 'SD']
  
  data[, c('MEAN', 'SD')] = NULL
  
  return(data)
}

id_home_environment = function(data, formula, group_variable) {
  # identify the home location for each group_variable, 
  # for the categories defined by envi_formula. Aggregates by mean, ignoring NA. 
  # Home is the highest mean for each category.
  
  home = split(data, data[, group_variable])
  
  home = lapply(names(home), function(x) {
    means = aggregate(formula, home[[x]], function(y) {
      mean(y, na.rm=TRUE)
    })
    fact_cols = seq(1:(ncol(means)-1))
    factors = names(means)[fact_cols]
    response = names(means)[ncol(means)]
    
    mx = max(means[, response])
    mx = data.frame(
      a = x,
      means[, factors],
      c = means[, response] == mx
    )
    colnames(mx) = c(group_variable, factors, 'IS_HOME')
    return(mx)
  })
  
  home = as.data.frame(
    do.call(rbind, home)
  )
  
  merge_by = colnames(home) != 'IS_HOME'
  merge_by = colnames(home)[merge_by]
  data = merge(data, home, by=merge_by)
  return(data)
}

rq_coefficient = function(data, ff, coefficient) {
  require(quantreg)
  # Pull mean of coefficient value for rq(ff, data)
  mod = rq(ff, data=data)
  vals = coef(mod)
  
  cc = grepl(coefficient, names(vals))
  vals = vals[cc]
}

coefficient_by_group = function(data, linear_model, groups, coefficient) {
  # pull coefficient from linear_model on data, split by groups
  data = split(data, data[, groups])
  
  coefs = sapply(data, function(x) {
    out = rq_coefficient(x, linear_model, coefficient)
    out = as.matrix(out)
    out = t(out)
    return(out)
  })
  
  return(coefs)
}

coefs_vector = function(data, field, coefs) {
  # sets uncalculated coefficients at 0 given data[, field], and cleans up names.
  
  lvls = unique(data[, field])
  out = rep(0, length(lvls))
  names(out) = lvls
  
  csub = grepl(field, names(coefs))
  csub = coefs[csub]
  names(csub) = gsub(field, "", names(csub))
  
  for (i in names(csub)) {
    out[i] = csub[i]
  }
  
  return(out)
}

simulate_data = function(data, coefs) {
  # simulates response for each observation in data, as defined by coefficients.
  # coefficients is a named list. names are factors, plus "intercept" and "error".
  # In this list, items named by factors are named generated by coefs_vector(). 
  require(foreach)
  
  # names of coefficients (not error or intercept)
  coef_names = names(coefs)
  tt = sapply(coef_names, function(x) !(x %in% c('intercept', 'error')))
  coef_names = coef_names[tt]
  
  # pull intercept
  intercept = coefs[['intercept']]
  
  sim_data = foreach(i=1:nrow(data), .combine='c') %do% {
    # simulate error
    sim_err = round(rnorm(1, mean=0, sd=coefs[['error']]), 3)
    
    # pull coefficients
    cc = c()
    for(j in coef_names) {
      tt = data[i, j]
      cc[j] = coefs[[j]][tt]
    }
    
    # add coefficients, error, intercept
    out = sum(intercept, sim_err, cc)
    out
  }
  
  out = data.frame(
    data[, coef_names],
    SIM = sim_data
  )
  
  tt = is.na(out[, 'SIM']) # remove those without possible estimates for coefficients.
  return(out[!tt, ])
}
